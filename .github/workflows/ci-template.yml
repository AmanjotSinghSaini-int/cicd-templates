name: Docker Build Reusable Workflow

on:
  workflow_call:
    inputs:
      image_name:
        required: true
        type: string
      image_tag:
        required: false
        type: string
        default: 'latest'
      dockerfile_path:
        required: false
        type: string
        default: './Dockerfile'
      context:
        required: false
        type: string
        default: '.'
      build_args:
        required: false
        type: string
        default: ''
      run_trivy:
        required: false
        type: boolean
        default: true
      continue_on_trivy_error:
        required: false
        type: boolean
        default: true
      run_gitleaks:
        required: false
        type: boolean
        default: true
      gitleaks_fetch_depth:
        required: false
        type: number
        default: 1
      continue_on_gitleaks_error:
        required: false
        type: boolean
        default: true
      run_pytest:
        required: false
        type: boolean
        default: true
      continue_on_pytest_error:
        required: false
        type: boolean
        default: false
      run_owasp:
        required: false
        type: boolean
        default: true
      continue_on_owasp_error:
        required: false
        type: boolean
        default: true
      image_size_threshold_mb:
        required: false
        type: number
        default: 100
      continue_on_size_check_error:
        required: false
        type: boolean
        default: false
      push_to_ecr:
        required: false
        type: boolean
        default: false
      ecr_repository:
        required: false
        type: string
      run_sonar:
        required: false
        type: boolean
        default: false
      sonar_host_url:
        required: false
        type: string
      sonar_project_key:
        required: false
        type: string
      sonar_project_name:
        required: false
        type: string
      fail_on_quality_gate:
        #description: "Fail pipeline if SonarQube quality gate or coverage fails"
        required: false
        type: boolean
        default: true
      min_coverage_percent:
        #description: "Minimum required coverage percentage"
        required: false
        type: number
        default: 70
      slack-channel:
        required: false
        type: string
        default: '#github-actions-notification'
      slack-enabled:
        required: false
        type: boolean
        default: true

    secrets:
      SLACK_WEBHOOK_URL:
        required: false
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true
      AWS_ACCOUNT_ID:
        required: true
      SONAR_TOKEN:
        required: false

jobs:
  gitleaks_scan:
    runs-on: ubuntu-latest
    if: ${{ inputs.run_gitleaks }}
    continue-on-error: ${{ inputs.continue_on_gitleaks_error }}
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: ${{ inputs.gitleaks_fetch_depth }}

      - name: Run Gitleaks scan
        run: |
          mkdir -p gitleaks-reports
          docker run --rm \
            -v ${{ github.workspace }}:/repo \
            -v ${{ github.workspace }}/gitleaks-reports:/output \
            zricethezav/gitleaks:latest detect \
            --source="/repo" \
            --report-format="json" \
            --report-path="/output/gitleaks-report.json"

      - name: Upload Gitleaks report
        if: always() && inputs.run_gitleaks
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: gitleaks-reports/gitleaks-report.json

  pytest:
    if: ${{ inputs.run_pytest }}
    runs-on: ubuntu-latest
    needs: [gitleaks_scan]
    continue-on-error: ${{ inputs.continue_on_pytest_error }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-html

      - run: pytest --html=pytest-report.html

      - uses: actions/upload-artifact@v4
        with:
          name: pytest-html-report
          path: pytest-report.html

  owasp_scan:
    runs-on: ubuntu-latest
    needs: [gitleaks_scan]
    if: ${{ inputs.run_owasp }}
    continue-on-error: ${{ inputs.continue_on_owasp_error }}
    steps:
      - uses: actions/checkout@v4

      - name: Run OWASP Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: "MyProject"
          path: "."
          format: "HTML"
          out: "dependency-check-reports"

      - uses: actions/upload-artifact@v4
        with:
          name: dependency-check-html-report
          path: dependency-check-reports/dependency-check-report.html

  sonarqube_scan:
    runs-on: ubuntu-latest
    needs: [owasp_scan]
    if: ${{ inputs.run_sonar == true || inputs.run_sonar == 'true' }}
    steps:
    - uses: actions/checkout@v4

    - uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Download and run SonarQube scanner
      id: sonar-scan
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
        unzip sonar-scanner-cli-5.0.1.3006-linux.zip
        export PATH="$PWD/sonar-scanner-5.0.1.3006-linux/bin:$PATH"

        sonar-scanner \
          -Dsonar.projectKey=${{ inputs.sonar_project_key }} \
          -Dsonar.projectName="${{ inputs.sonar_project_name }}" \
          -Dsonar.host.url=${{ inputs.sonar_host_url }} \
          -Dsonar.login=$SONAR_TOKEN \

    - name: Wait for SonarQube Quality Gate result
      if: ${{ inputs.fail_on_quality_gate == 'true' }}
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ inputs.sonar_host_url }}
        PROJECT_KEY: ${{ inputs.sonar_project_key }}
      run: |
        echo "🔍 Checking Quality Gate status..."
        sleep 10

        ANALYSIS_ID=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_HOST_URL/api/ce/component?component=$PROJECT_KEY" | jq -r '.queue[0].id')

        if [[ -z "$ANALYSIS_ID" || "$ANALYSIS_ID" == "null" ]]; then
          echo "❌ Could not get analysis ID. Exiting."
          exit 1
        fi

        echo "Got analysis ID: $ANALYSIS_ID"
        STATUS="PENDING"

        for i in {1..10}; do
          STATUS=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_HOST_URL/api/qualitygates/project_status?analysisId=$ANALYSIS_ID" | jq -r '.projectStatus.status')
          echo "Quality Gate Status: $STATUS"
          if [[ "$STATUS" != "PENDING" ]]; then
            break
          fi
          sleep 5
        done

        if [[ "$STATUS" != "OK" ]]; then
          echo "❌ Quality Gate failed."
          exit 1
        else
          echo "✅ Quality Gate passed."
        fi

    - name: Check Code Coverage Threshold
      if: ${{ inputs.fail_on_quality_gate == 'true' }}
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ inputs.sonar_host_url }}
        PROJECT_KEY: ${{ inputs.sonar_project_key }}
        MIN_COVERAGE: ${{ inputs.min_coverage_percent }}
      run: |
        echo "📈 Fetching coverage value from SonarQube..."
        COVERAGE=$(curl -s -u "$SONAR_TOKEN:" \
          "$SONAR_HOST_URL/api/measures/component?component=$PROJECT_KEY&metricKeys=coverage" \
          | jq -r '.component.measures[0].value')

        if [[ -z "$COVERAGE" || "$COVERAGE" == "null" ]]; then
          echo "⚠️ No coverage data available. Skipping coverage check."
          exit 0
        fi

        echo "Coverage: $COVERAGE%"
        COVERAGE_INT=$(printf "%.0f" $COVERAGE)
        THRESHOLD=$(printf "%.0f" $MIN_COVERAGE)

        if [ "$COVERAGE_INT" -lt "$THRESHOLD" ]; then
          echo "❌ Coverage ($COVERAGE_INT%) is below threshold ($THRESHOLD%). Failing."
          exit 1
        else
          echo "✅ Coverage ($COVERAGE_INT%) meets or exceeds threshold."
        fi


  docker_build:
    runs-on: ubuntu-latest
    needs: [pytest, owasp_scan, sonarqube_scan]
    outputs:
      image_name: ${{ inputs.image_name }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract image base name
        id: image_vars
        run: |
          IMAGE_NAME="${{ inputs.image_name }}"
          BASE_NAME=$(basename "${IMAGE_NAME}" | cut -d':' -f1)
          TAR_NAME="${BASE_NAME//[^a-zA-Z0-9]/_}_${{ inputs.image_tag }}.tar"
          echo "tar_name=$TAR_NAME" >> $GITHUB_OUTPUT

      - name: Build Docker image
        run: |
          docker build \
            -t ${{ inputs.image_name }}:${{ inputs.image_tag }} \
            -f ${{ inputs.dockerfile_path }} \
            ${{ inputs.build_args }} \
            ${{ inputs.context }}

      - name: Save Docker image to archive
        run: docker save -o ${{ steps.image_vars.outputs.tar_name }} ${{ inputs.image_name }}:${{ inputs.image_tag }}

      - uses: actions/upload-artifact@v4
        with:
          name: built-docker-image-${{ inputs.image_tag }}
          path: ${{ steps.image_vars.outputs.tar_name }}

  trivy_scan:
    if: ${{ inputs.run_trivy }}
    runs-on: ubuntu-latest
    needs: docker_build
    continue-on-error: ${{ inputs.continue_on_trivy_error }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: built-docker-image-${{ inputs.image_tag }}

      - name: Load Docker image
        run: |
          IMAGE_NAME="${{ inputs.image_name }}"
          TAG="${{ inputs.image_tag }}"
          BASE_NAME=$(basename "${IMAGE_NAME}" | cut -d':' -f1)
          TAR_NAME="${BASE_NAME//[^a-zA-Z0-9]/_}_${TAG}.tar"
          docker load -i "$TAR_NAME"

      - name: Trivy scan
        run: |
          mkdir -p trivy-reports
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v ${{ github.workspace }}/trivy-reports:/output \
            aquasec/trivy:latest \
            image ${{ inputs.image_name }}:${{ inputs.image_tag }} \
            --format table \
            --ignore-unfixed \
            --vuln-type os,library \
            -o /output/trivy-report.txt

      - uses: actions/upload-artifact@v4
        with:
          name: trivy-report
          path: trivy-reports/trivy-report.txt

  docker_image_size_check:
    runs-on: ubuntu-latest
    needs: [docker_build]
    outputs:
      pass_size_check: ${{ steps.check_size.outputs.pass_size_check }}
    continue-on-error: ${{ inputs.continue_on_size_check_error }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: built-docker-image-${{ inputs.image_tag }}

      - name: Load Docker image
        run: |
          IMAGE_NAME="${{ inputs.image_name }}"
          TAG="${{ inputs.image_tag }}"
          BASE_NAME=$(basename "${IMAGE_NAME}" | cut -d':' -f1)
          TAR_NAME="${BASE_NAME//[^a-zA-Z0-9]/_}_${TAG}.tar"
          docker load -i "$TAR_NAME"

      - id: check_size
        run: |
          IMAGE_SIZE=$(docker image inspect "${{ inputs.image_name }}:${{ inputs.image_tag }}" --format='{{.Size}}')
          SIZE_MB=$((IMAGE_SIZE / 1024 / 1024))
          THRESHOLD=${{ inputs.image_size_threshold_mb }}
          echo "Image size is ${SIZE_MB} MB (Threshold: ${THRESHOLD} MB)"
          if [ "$SIZE_MB" -le "$THRESHOLD" ]; then
            echo "pass_size_check=true" >> $GITHUB_OUTPUT
          else
            echo "pass_size_check=false" >> $GITHUB_OUTPUT
            if [ "${{ inputs.continue_on_size_check_error }}" != "true" ]; then
              exit 1
            fi
          fi

  push_to_ecr:
    runs-on: ubuntu-latest
    needs: [trivy_scan, docker_image_size_check]
    if: >
      ${{
        inputs.push_to_ecr &&
        (
          needs.docker_image_size_check.outputs.pass_size_check == 'true' ||
          inputs.continue_on_size_check_error
        )
      }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: built-docker-image-${{ inputs.image_tag }}

      - name: Load Docker image
        run: |
          IMAGE_NAME="${{ inputs.image_name }}"
          TAG="${{ inputs.image_tag }}"
          BASE_NAME=$(basename "${IMAGE_NAME}" | cut -d':' -f1)
          TAR_NAME="${BASE_NAME//[^a-zA-Z0-9]/_}_${TAG}.tar"
          docker load -i "$TAR_NAME"

      - name: Log in to AWS ECR
        uses: aws-actions/amazon-ecr-login@v1
        with:
          mask-password: true

      - name: Tag image for AWS ECR
        run: |
          ECR_IMAGE="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${{ inputs.ecr_repository }}:${{ inputs.image_tag }}"
          docker tag ${{ inputs.image_name }}:${{ inputs.image_tag }} $ECR_IMAGE
          echo "ECR_IMAGE=$ECR_IMAGE" >> $GITHUB_ENV

      - name: Push to AWS ECR
        run: docker push ${{ env.ECR_IMAGE }}

  slack_notify:
    runs-on: ubuntu-latest
    needs: [push_to_ecr]
    if: always()

    steps:
    - name: Determine job outcome
      id: outcome
      run: |
        result="${{ needs.push_to_ecr.result }}"
        echo "Result from push_to_ecr: $result"

        if [[ -z "$result" ]]; then
          echo "status=cancelled" >> $GITHUB_OUTPUT
        elif [[ "$result" == "failure" || "$result" == "skipped" ]]; then
          echo "status=failure" >> $GITHUB_OUTPUT
        else
          echo "status=success" >> $GITHUB_OUTPUT
        fi

    - name: Send Slack notification
      if: ${{ inputs.slack-enabled }}
      uses: act10ns/slack@v1
      with:
        webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
        channel: ${{ inputs.slack-channel }}
        status: ${{ steps.outcome.outputs.status }}
